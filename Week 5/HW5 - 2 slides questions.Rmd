---
title: "Week 5 HW Qi"
author: "Qi Hao"
date: "2/15/2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
### 1. use rbenchmark package to assess if there is any performance difference between using apply, sapply, lapply, and a for loop. 
```{r }
setwd("/Users/qihao/OneDrive/博三下/PLS900")
load("polity_dataframe.rda")

### write a function called functiona to do the descriptive data
functiona <-function(alist){
  n = length(alist)
  numberNA = sum(is.na(alist))
  b = mean(alist, na.rm = T)
  c = median(alist, na.rm = T)
  d = max(alist, na.rm = T)
  e = min(alist, na.rm = T)
  f = sd(alist, na.rm = T)
  return(c(n,numberNA,b,c,d,e,f ))
}

### create a function for each of sapply, apply, lapply and for loop
sapplydf <- function(adataframe){
  df <- sapply(adataframe, functiona)
  rownames(df) <- c("n","numberNA", "mean","median","max","min","stdev")
  return(df)
}

applydf <- function(adataframe){
  df <- apply(adataframe, 2, functiona)
  rownames(df) <- c("n","numberNA", "mean","median","max","min","stdev")
  return(df)
}

lapplydf <- function(adataframe){
  df <- do.call(cbind, lapply(adataframe,functiona))
  rownames(df) <- c("n","numberNA", "mean","median","max","min","stdev")
  return(df)
}

fordf <- function(avector){
  df <- data.frame(democ = rep(0,7),autoc = rep(0,7), polity2 = rep(0,7), xconst = rep(0,7))
  for (i in avector){
    df[,i] <- functiona(polity[,i])
}
  rownames(df) <- c("n","numberNA", "mean","median","max","min","stdev")
  return(df)
}

### use benchmark to find out how they excel/suck
library(rbenchmark)
df <-polity[,c('democ','autoc','polity2','xconst')]
avect <- c('democ','autoc','polity2','xconst')
benchmark(replications = 10, fordf(avect),sapplydf(df),applydf(df),lapplydf(df))

```
#### use tapply and dplyr to calculate the mean, median, and stdev of democ and xconst for every year in the polity dataframe object
```{r }
library(dplyr)
### in the slides Shahryar showed democ but in the instruction said polity2, not sure which one, just go with democ
selecteddata <- group_by(polity[,c("year","democ","xconst")], year)
### I figured once i use summarise_all, i don't have to use tapply
by_year <- summarise_all(selecteddata, mean, na.rm = T)

by_year_me <- summarise_all(selecteddata, median, na.rm = T)

by_year_sd <- summarise_all(selecteddata, sd, na.rm = T)

result <- cbind(by_year,by_year_me[,2:3])
result <- cbind(result, by_year_sd[,2:3])
colnames(result) <- c("year","democ_mean","xconst_mean","democ_median","xconst_median","democ_sd","xconst_sd")
result
```
# Wickham functions 
```{r setup, include=FALSE}
# knitr::opts_chunk$set(echo = TRUE)
library(magrittr)
```

# Function components

#### 1. What function allows you to tell if an object is a function? What function allows you to tell if a function is a primitive function?

is.function() and is.primitive() test whether an object is in those classes.

#### 2. This code makes a list of all functions in the base package.

``` {r}
objs <- mget(ls("package:base"), inherits = TRUE)
funs <- Filter(is.function, objs)
```

* Which base function has the most arguments?

```{r}
arglengths <- sapply(funs, formals) %>%
  sapply(length)
arglengths[which(arglengths == max(arglengths))]
```

* How many base functions have no arguments? What’s special about those functions?

```{r}
sum(arglengths == 0 | sapply(arglengths, is.null))
```

* How could you adapt the code to find all primitive functions?

```{r}
prim.funs <- Filter(is.primitive, objs)
```

#### 3. What are the three important components of a function?

* body
* formals
* environment

#### 4. When does printing a function not show what environment it was created in?

When the function was created in the global environment.

# Lexical scoping

#### 1. What does the following code return? Why? What does each of the three c’s mean?

```{r}
c <- 10
c(c = c)
```

This returns a vector of length 1 with a numeric 10 and the name 'c'. The first c means that contents will be vector, and it also allows naming the element. The second c is the name and the third pulls the pre-defined object c from the global environment.

#### 2. What are the four principles that govern how R looks for values?

* name masking
* functions vs. variables
* a fresh start
* synamic lookup

### 3. What does the following function return? Make a prediction before running the code yourself.

202

# Function arguments

### 1. Clarify the following list of odd function calls:

```{r}
x <- sample(replace = TRUE, 20, x = c(1:10, NA))
```

Samples 20 values from possible values c(1:10, NA) with replacement.

```{r}
y <- runif(min = 0, max = 1, 20)
```

Generates 20 values from a uniform distribution between 0 and 1.

```{r}
cor(m = "k", y = y, u = "p", x = x)
```

Calculates a pearson correaltion between x and y with pairwise deletion.

#### 2. What does this function return? Why? Which principle does it illustrate?

```{r}
f1 <- function(x = {y <- 1; 2}, y = 0) {
  x + y
}
f1()
```

It returns 3 since y is defined as 1 earlier in the function than when it's defined as 0. This exemplifies lazy evaluation.

#### 3. What does this function return? Why? Which principle does it illustrate?

```{r}
f2 <- function(x = z) {
  z <- 100
  x
}
f2()
```

This returns 100 because once z has a value, the argument definition assigns that to x as well. This also exemplifies lazy evaluation.


### Wickham functional programming
```{r }

```
## R Markdown

